**离线构建整个查询区间的划分树**
对于区间[l,r]，首先通过对原数列排序找到这个区间的中间值位置mid = l+r/2(向下取整)
if num<=mid 划入左子树[l,mid]
if num>mid 划入右子树[mid+1,r]
对于第i个数，记录再[l,i]区间内有多少整数被划入左子树，然后继续对它的左子树区间[l,mid]和右子树区间[mid+1,r]递归建树，直至花粉出最后一层的叶结点为止。


    ```c++
    void build(int l,int r,int dep)
    {
        if(l==r)return;
        int mid = (l+r)>>1;
        int same = mid -1 + 1;
        for(int i = 1;i<=r;i++)
        {
            if(tree[dep][i]<sorted[mid])
            {
                same--;
            }
        }
        int lpos = 1;
        int rpos = mid+1;
        for(int i=1;i<=r;i++)
        {
            if(tree[dep][i]<sorted[mid])
            {
                tree[dep+1][lpos++]=tree[dep][i];
            }
            else if(tree[dep][i]==sorted[mid]&&same>0)
            {
                tree[dep+1][lpos++]=tree[dep][i];
                same--;
            }
            else
            {
                tree[dep+1][rpos++]=tree[dep][i];
            }
            toleft[dep][i]=toleft[dep][l-1]+lpos-1;
        }
        build(1,mid,dep+1);
        build(mid+1,r,dep+1);
    }
    ```
    
    

