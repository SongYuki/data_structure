**利用最小生成树及其扩展形式解题**
+ 设G=(V,E,w)是连通的有权无向图（节点集为V，边集为E，边权集为w）连通图G中包含所有节点，且只有|V|-1条边的连通子图即为G的生成树。边权值和最小的生成树称为最小生成树。

+ 构建最小生成树
+ 应用最小生成树原理优化算法
+ 最优比率生成树
+ 最小k度限制生成树
+ 次小生成树的解法

**最小生成树的思想和应用**
A是一棵最小生成树的子集，如果边(u,v)不属于A且A并{(u,v)}仍然是某一棵最小生成树的子集，就称(u,v)为集合A的安全边。由此引出计算最小生成树的一般思想

    ```
    A=[]; //最小生成树初始时为空
    while(A没有形成一棵生成树)  //A中的边数不足|V|-1
    {
        找出A的一条安全边(u,v);
        A=A∪{(u,v)};
        //(u,v)加入最小生成树
    };
    Return A; //返回最小生成树
    ```
    
计算最小生成树的常用方法有Prim算法和Kruskal算法，两种算法都采用了“贪心”策略
**(1)Prim算法**
+ 如果用相邻矩阵w[][]存储图，用一维数组key[]存储每个树外节点到树中节点的边所具有的最小权值（最短距离值）用π[]记录生成树中每个节点的父亲，用队列Q存储树外节点。

    ```
    void PRIM(G,w,r)  //图G的相邻矩阵为w 构建以r为根的最小生成树
    {
        Q=V[G]; //所有节点送入队列Q
        for(每个u∈Q)key[u]=∞//所有节点的最短距离初始化为∞
        key[r]=0;//根r的最短距离值为0
        π[r]=NULL;//r的父节点为空，即r进入生成树
        while(Q<>空集)//若队列不空
        {
            u=EXTRACT-MIN(Q);//队列Q中距离值最小的节点u出队进入生成树
            for(每个v∈Adj[u])//对Q中u相邻的每个节点v进行松弛操作：若v在队列Q且(u,v)的边权小于原距离值，则v的父亲调整为u距离值调整为(u,v)的边权
            if(v∈Q)&&(w(u,v)<key[v])
            {
                π[v]=u;
                key[v]=w(u,v);
            }
        }
    }
    ```
    
**如果队列Q采用一维数组存储，累计整个算法的运行时间为O(|V|^2);如果队列Q采用小根堆组存储，则算法的运行时间可降为O(|V|*log2|V|)**

**Prim算法的时间复杂度取决于节点数|V|而与边数|E|无关，因此一般适用于稠密图**


**(2)Kruskal算法**

    ```
    void KRUSKAL(G,w)
    {
        A=空集 //最小生成树的子集初始化为空
        For(每个节点v∈V[G])v自成一个集合；
        根据边权递增的顺序排序边表E;
        for(顺序搜索E中的每条边(u,v))
        {
            if(u,v属于两个不同的集合)
            {
                A=A∪{(u,v)};   //(u,v)进入生成树A
                合并u和v所在的两个集合
            }
        }
        return A;
        //返回生成树A
    }
    ```
    
**Kruskal算法的全部运行时间为O(|E|*log2|E|)**
**Kruskal算法的时间复杂度取决于边数|E|而与节点数|V|无关，因此一般适用于稀疏图**

