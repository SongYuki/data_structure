# 游戏之乐

标签（空格分隔）： 编程之美

---
**Question**:
写一个程序，让用户来决定windows task manager的CPU占用率，程序越精简越好，计算机语言不限。
例如，可以实现下面三种情况
1.CPU的占用率固定在50%为一条直线
2.CPU的占用率为一条直线，但是具体占用率由命令行参数决定（参数范围：1-100）
3.CPU的占用率状态是一个正弦曲线

**Analyze**:
通过task manager的进程process一栏可以看到，System Idle Process占用了CPU空闲的时间
系统中的进程在等待用户输入或者等待某些事件的发生或者主动进入休眠状态时，它们会“闲下来”

在task manager的一个刷新周期内，CPU忙（执行应用程序）的时间和刷新周期总时间的比率，就是CPU的占用率。任务管理器中显示的是每个刷新周期内CPU占用率的统计平均值。
我们可以写一个程序，让它在task manager的刷新期间内一会儿忙一会儿闲，然后通过调节忙/闲的比例，就可以控制任务管理器中显示的CPU占用率

**answer:**
**simple:**
使CPU在一段时间内跑busy/idle两个不同的循环loop，从而通过不同的时间比例，来调节CPU的使用率
busy loop可以通过执行空循环来实现，idle可以通过Sleep()来实现
对于一个空循环for(i=0;i<n;i++)该如何来估算这个最合适的n值呢？CPU执行的是机器指令而最接近于机器指令的语言是汇编语言，可以先把空循环简单写成如下汇编代码后进行分析：
loop:
mov dx i;
inc dx;
mov i dx;
cmp i n;
jl loop;

假设这段代码运行的CPU是2.4Ghz(2.4*10^9个时钟周期每秒)现代CPU每个时钟周期可以执行两条以上的代码取平均值两条(（2.4*10^9）*2)/5=9.6*10^8(循环/秒)也就是说CPU一秒钟可以运行这个空循环9.6*10^8次
尝试降低两个数量级，n=9.6*10^6睡眠时间相应改为10mm(Sleep(10))用10毫秒是因为比较接近windows的调度时间片

    int main()
    {
        for(;;)
        {
            for(int i=0;i<9600000;i++)
            {
                ;
            }
 Sleep(10);
        }
        return 0;
    }


**Notice:**
1.尽量减少sleep/awake的频率，减少操作系统内核调度程序的干扰
2.尽量不要调用system call(I/O这些privilege instruction)因为它也会导致很多不可控的内核运行时间

**Answer：**
**Advanced：**
GetTickCount()得到“系统启动到现在”所经历时间的毫秒值，最多能统计到49.7天，可以利用GetTickCount()来判断busy loop要循环多久

    int busyTime = 10;//10ms
    int idleTime = busyTime://same ratio will lead to 50% cpu usage
    Int64 statrtTime = 0;
    while(true)
    {
        startTime = GetTickCount()
        //busy loop
        while(GetTickCount()-startTime<=busyTime)
        {
            ;
        }
        //idle loop
        Sleep(idleTime);
    }
    
    
**Tips:**
Perfmon是从Windows NT开始就包含在Windows管理工具组中的专业检测工具之一。
可以通过写程序查询Perfmon的值，Microsoft 。Net Framework提供了PerformanceCounter这一对象，可以方便地得到当前各种性能数据，包括CPU的使用率

**Answer:**
**Dynamic:**

    //C# code
    static void MakeUsage(float level)
    {
        PerformanceCounter p = new PerformanceCounter("Processor","% Processor Time","_Total");
        while(true)
        {
            if(p.NextValue()>level)
            {
                System.Threading.Thread.Sleep(10);
            }
        }
    }



使用这个解法能方便地处理各种CPU使用率参数。


**Answer:**
**Sin Curv Line:**

    //C++ code to make task manager generate sine graph
    #include"Windows.h"
    #include"stdlib.h"
    #include"math.h"
    const double SPLIT =0.01;
    const int COUNT =200;
    const double PI = 3.14159265;
    const int INTERVAL = 300;
    
    int _tmain(int argc,_TCHAR* argv[])
    {
        DWORD busySpan[COUNT];//array of busy times
        DWORD idleSpan[COUNT];//array of idle times
        int half = INTERVAL/2;
        double radian = 0.0;
        for(int i=0;i<COUNT;i++)
        {
            busySpan[i]=(DWORD)(half+(sin(PI*radian)*half));
            idleSpan[i]=INTERVAL-busySpan[i];
            radian += SPLIT;
        }
        DWORD startTime = 0;
        int j = 0;
        while(true)
        {
            j = j%COUNT;
            startTime = GetTickCount();
            while((GetTickCount()-startTime)<=busySapn[j])
            {
                ;
            }
            Sleep(idleSpan[j]);
            j++;
        }
        return 0;
    }
    
    

**FutherMore:**
多CPU的问题首先需要获得系统的CPU信息。可以使用GetProcessorInfo()获得多处理器的信息，然后指定进程在哪一个处理器上运行。其中指定运行使用的是SetThreadAffinityMask()函数

还可以使用RDTSC指令获取当前CPU核心运行周期数
在x86平台上定义函数
inline _int64 GetCPUTickCount()
{
    _asm
    {
        rdtsc;
    }
}

在x64平台上定义
#define GetCPUTickCount() _rdtsc()

**使用CallNtPowerInformation API得到CPU频率，从而将周期数转化为毫秒数**

    _PROCESSOR_POWER_INFOMATION info;
    
    CallNTPowerInfomation(11,//query processor power information
    NULL, //no input buffer
    0,//input buffer size is zero
    &info,//output buffer
    Sizeof(info));  //outbuf size
    
    _int64 t_begin = GetCPUTickCount();
    //do something
    _int64 t_end = GetCPUTickCount();
    double millisec = ((double)t_end-(double)t_begin)/(double)info.CurrentMhz;
    
    
**RDTSC指令读取当前CPU的周期数，在多CPU系统中，这个周期数在不同的CPU之间基数不同，频率也有可能不同。用从两个不同的CPU得到的周期数作计算会得出没有意义的值。如果线程在运行中被调度到了不同的CPU，就会出现上述情况。可用SetThreadAffinityMask避免线程迁移。另外，CPU的频率会随系统供电及负荷情况有所调整。**

**Conclude:**
了解当前线程/进程/系统效能的API大致有以下这些
1.Sleep() -- 这个方法能让当前线程“停”下来
2.WaitForSingleObject() -- 自己停下来，等待某个事件发生。
3.GetTickCount()--获得时钟周期
4.QueryPerformanceFrequency()/QueryPerformanceCounter()--让你访问精度更高的CPU数据
5.timeGetSystemTime()--是另一个得到高精度时间的方法
6.PerformanceCounter -- 效能计数器
7.GetProcessorInfo()/SetThreadAffinityMask()遇到多核问题，这两个方法帮你更好控制CPU
8.GetCPUTickCount()--拿到CPU核心运行周期数


